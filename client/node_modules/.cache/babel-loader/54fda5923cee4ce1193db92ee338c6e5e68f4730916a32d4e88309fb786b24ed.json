{"ast":null,"code":"import utils from '../utils.js';\nimport httpAdapter from './http.js';\nimport xhrAdapter from './xhr.js';\nimport * as fetchAdapter from './fetch.js';\nimport AxiosError from \"../core/AxiosError.js\";\n\n/**\r\n * Known adapters mapping.\r\n * Provides environment-specific adapters for Axios:\r\n * - `http` for Node.js\r\n * - `xhr` for browsers\r\n * - `fetch` for fetch API-based requests\r\n * \r\n * @type {Object<string, Function|Object>}\r\n */\nconst knownAdapters = {\n  http: httpAdapter,\n  xhr: xhrAdapter,\n  fetch: {\n    get: fetchAdapter.getFetch\n  }\n};\n\n// Assign adapter names for easier debugging and identification\nutils.forEach(knownAdapters, (fn, value) => {\n  if (fn) {\n    try {\n      Object.defineProperty(fn, 'name', {\n        value\n      });\n    } catch (e) {\n      // eslint-disable-next-line no-empty\n    }\n    Object.defineProperty(fn, 'adapterName', {\n      value\n    });\n  }\n});\n\n/**\r\n * Render a rejection reason string for unknown or unsupported adapters\r\n * \r\n * @param {string} reason\r\n * @returns {string}\r\n */\nconst renderReason = reason => \"- \".concat(reason);\n\n/**\r\n * Check if the adapter is resolved (function, null, or false)\r\n * \r\n * @param {Function|null|false} adapter\r\n * @returns {boolean}\r\n */\nconst isResolvedHandle = adapter => utils.isFunction(adapter) || adapter === null || adapter === false;\n\n/**\r\n * Get the first suitable adapter from the provided list.\r\n * Tries each adapter in order until a supported one is found.\r\n * Throws an AxiosError if no adapter is suitable.\r\n * \r\n * @param {Array<string|Function>|string|Function} adapters - Adapter(s) by name or function.\r\n * @param {Object} config - Axios request configuration\r\n * @throws {AxiosError} If no suitable adapter is available\r\n * @returns {Function} The resolved adapter function\r\n */\nfunction getAdapter(adapters, config) {\n  adapters = utils.isArray(adapters) ? adapters : [adapters];\n  const {\n    length\n  } = adapters;\n  let nameOrAdapter;\n  let adapter;\n  const rejectedReasons = {};\n  for (let i = 0; i < length; i++) {\n    nameOrAdapter = adapters[i];\n    let id;\n    adapter = nameOrAdapter;\n    if (!isResolvedHandle(nameOrAdapter)) {\n      adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];\n      if (adapter === undefined) {\n        throw new AxiosError(\"Unknown adapter '\".concat(id, \"'\"));\n      }\n    }\n    if (adapter && (utils.isFunction(adapter) || (adapter = adapter.get(config)))) {\n      break;\n    }\n    rejectedReasons[id || '#' + i] = adapter;\n  }\n  if (!adapter) {\n    const reasons = Object.entries(rejectedReasons).map(_ref => {\n      let [id, state] = _ref;\n      return \"adapter \".concat(id, \" \") + (state === false ? 'is not supported by the environment' : 'is not available in the build');\n    });\n    let s = length ? reasons.length > 1 ? 'since :\\n' + reasons.map(renderReason).join('\\n') : ' ' + renderReason(reasons[0]) : 'as no adapter specified';\n    throw new AxiosError(\"There is no suitable adapter to dispatch the request \" + s, 'ERR_NOT_SUPPORT');\n  }\n  return adapter;\n}\n\n/**\r\n * Exports Axios adapters and utility to resolve an adapter\r\n */\nexport default {\n  /**\r\n   * Resolve an adapter from a list of adapter names or functions.\r\n   * @type {Function}\r\n   */\n  getAdapter,\n  /**\r\n   * Exposes all known adapters\r\n   * @type {Object<string, Function|Object>}\r\n   */\n  adapters: knownAdapters\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}